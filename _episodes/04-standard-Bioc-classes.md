---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 04-standard-Bioc-classes.md in _episodes_rmd/
source: Rmd
title: "Standard Bioconductor classes"
teaching: XX
exercises: XX
questions:
- "What is the S4 class system?"
- "How do we access information stored in S4 objects?"
- "How to we combine methods and classes from different packages into a practical workflow?"
objectives:
- "Explain core S4 concepts: class, object, slots, validity, methods."
- "Identify common classes and methods used in the Bioconductor project."
- "Create objects and process them using methods from differerent packages in a single workflow."
keypoints:
- "Common methods and classes promote interoperability between packages, reduce redundant efforts by package developers, and facilitate the writing of workflows"
- "S4 classes can represent arbitrarily complex data structures."
- "S4 classes perform validity checks and report invalid object states."
---



> ## Contribute!
> 
> This episode is intended to introduce some core Bioconductor classes to illustrate key concepts of S4 classes and methods.
> Preferably some conceptually simple classes that can be used for intuitive exercises.
>
> The exercises should focus on illustrating:
>
> - slots
> - validity checks (and fails)
> - method dispatch
> - `show()` method (in contrast to the `str()` function)
> 
> For instance, use the *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* class to:
> 
> - Illustrate how to create a new object
> - Show that validity checks prevent the creation of invalid objects (e.g. only A-T-C-G in `DNAStringSet` objects).
>
{: .callout}

# Why standard classes?

> ## Contribute!
> 
> This section is a general discussion of the purpose and advantages of having standard classes re-used throughout the community.
> 
> Discuss:
> 
> - Interoperability.
> - Re-use and inheritance.
> - Community effort to discuss, develop, update, and maintain classes and methods.
>
{: .callout}


# S4 class system

> ## Contribute!
> 
> This section is a general illustration of S4 classes and their organisation.
> 
> Illustrate:
> 
> - Slots
> - Re-use and inheritance (be careful about redundancy with the section above).
> - Methods (e.g. `show()`)
>
{: .callout}

## Defining a new class

The [methods][pkg-methods] R package - included in the set of core packages installed with R - provides functions to define and register [S4 classes][glossary-s4-class].

A new S4 class is defined using the function `setClass`.
At its simplest, a class can defined from a name and a list of [slots][glossary-s4-slot].

The class name will be used to identify [S4 objects][glossary-s4-object] of that class, allowing [method dispatch][glossary-method-dispatch] to call the appropriate method designed to process objects of that type.

Each _class slot_ identified by its name and the type of data that it will contain.

- a name
- a named character vector of _slots_ and data types that each slot is allowed to contain

For example, we can create a class called "Experiment", that contains:

- a _title_, as a `character` vector
- a numeric _matrix_
- some _metadata_, as a `data.frame` (e.g., one row per sample, one column per attribute)


~~~
setClass("Experiment", slots=c(
    title = "character",
    matrix = "matrix",
    metadata = "data.frame"
    ))
~~~
{: .language-r}

## Instantiating objects of a class

Once a class has been defined, new objects of that class can be instantiated (i.e., created) using the `new()` function.
Those new objects can be assigned to variable name for subsequent use, including display in the console.


~~~
experiment1 <- new("Experiment")
experiment1
~~~
{: .language-r}



~~~
An object of class "Experiment"
Slot "title":
character(0)

Slot "matrix":
<0 x 0 matrix>

Slot "metadata":
data frame with 0 columns and 0 rows
~~~
{: .output}

Notice that the definition of the slots ensures that we cannot assign data of the wrong type to any of the slots.
Each value that does not match the type of the slot generates a validity error message.


~~~
experiment1 <- new("Experiment", 
    title = 2,
    matrix = matrix("A"),
    metadata = list()
)
~~~
{: .language-r}



~~~
Error in validObject(.Object): invalid class "Experiment" object: 1: invalid object for slot "title" in class "Experiment": got class "numeric", should be or extend class "character"
invalid class "Experiment" object: 2: invalid object for slot "metadata" in class "Experiment": got class "list", should be or extend class "data.frame"
~~~
{: .error}

However, rather than letting users call the `new()` function, it is generally best practice to implement a _contructor_ function.
A constructor function typically calls the `new()` function, after potentially performing additional validity checks beyond the type of arguments, and processing arguments into the actual values that will be stored in the various slots of the final object.
Best practice is to name constructor functions identically to the name of class that they instantiate objects for.


~~~
Experiment <- function(title, matrix, metadata) {
    title <- as.character(title)
    matrix <- as.matrix(matrix)
    storage.mode(matrix) <- "numeric"
    metadata <- as.data.frame(metadata)
    new("Experiment", 
        title = title,
        matrix = matrix,
        metadata = metadata
    )
}
Experiment(
    title = 2,
    matrix = matrix("1", dimnames = list("A", "a")),
    metadata = list(A = 1, B = 2))
~~~
{: .language-r}



~~~
An object of class "Experiment"
Slot "title":
[1] "2"

Slot "matrix":
  a
A 1

Slot "metadata":
  A B
1 1 2
~~~
{: .output}



# Install packages


~~~
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Biostrings")
~~~
{: .language-r}


# The Biostrings package and classes

Many bioinformatics analyses focus on biological sequences that are often represented as strings or characters vectors.
Examples include nucleic acid sequences (e.g., DNA, RNA), and protein sequences composed of aminoacids.

The *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package implements classes to represent such sequences as S4 classes, e.g. `DNAString`, `AAString`.
Those S4 classes provide memory-efficient string containers, while other methods implemented in the package provide various string matching algorithms and other utilities for fast manipulation of large biological sequences or sets of sequences.

A short presentation of the basic classes defined in the *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package is available in one of the package vignettes.


~~~
vignette("Biostrings2Classes")
~~~
{: .language-r}

To get started, we load the package.


~~~
library(Biostrings)
~~~
{: .language-r}

With the package loaded and attached to the session, we have access to the packages functions.
Those include functions that let us create new objects of the classes defined in the package; those functions are called _constructors_.
For instance, we can create an object that represents a DNA sequence, using the `DNAString()` constructor function.


~~~
DNAString("ATCG")
~~~
{: .language-r}



~~~
4-letter DNAString object
seq: ATCG
~~~
{: .output}

Notably, DNA sequences may only contain the characters A, T, C, and G, to represent the four DNA nucleotide.
Notice that the constructor function does not let us create objects that contain invalid characters, that do not represent any of those four nucleotide.


~~~
DNAString("ATCG")
~~~
{: .language-r}



~~~
4-letter DNAString object
seq: ATCG
~~~
{: .output}


~~~
DNAString("ATCGE")
~~~
{: .language-r}



~~~
Error in .Call2("new_XString_from_CHARACTER", class(x0), string, start, : key 69 (char 'E') not in lookup table
~~~
{: .error}

That said, the symbols that compose the alphabet DNA sequences are not limited to the characters A, T, C, and G.
The [IUPAC Extended Genetic Alphabet][iupac-alphabet] defines additional nucleotide code that represent combinations of nucleotides, in a way similar to regular expressions.
The `IUPAC_CODE_MAP` 


~~~
IUPAC_CODE_MAP
~~~
{: .language-r}



~~~
     A      C      G      T      M      R      W      S      Y      K      V 
   "A"    "C"    "G"    "T"   "AC"   "AG"   "AT"   "CG"   "CT"   "GT"  "ACG" 
     H      D      B      N 
 "ACT"  "AGT"  "CGT" "ACGT" 
~~~
{: .output}

Any of those nucleotide codes are allowed in the sequence of a `DNAString` object.


~~~
DNAString("ATCGM")
~~~
{: .language-r}



~~~
5-letter DNAString object
seq: ATCGM
~~~
{: .output}

[pkg-methods]: https://stat.ethz.ch/R-manual/R-devel/library/methods/html/00Index.html
[iupac-alphabet]: https://www.bioinformatics.org/sms/iupac.html
[glossary-s4-slot]: ../reference.html#s4-class-slot
[glossary-s4-class]: ../reference.html#s4-class
[glossary-s4-object]: ../reference.html#s4-object
[glossary-s4-dispatch]: ../reference.html#s4-method-dispatch
