---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 04-standard-Bioc-classes.md in _episodes_rmd/
source: Rmd
title: "Standard Bioconductor classes"
teaching: XX
exercises: XX
questions:
- "What is the S4 class system?"
- "How do we access information stored in S4 objects?"
- "How to we combine methods and classes from different packages into a practical workflow?"
objectives:
- "Explain core S4 concepts: class, object, slots, validity, methods."
- "Identify common classes and methods used in the Bioconductor project."
- "Create objects and process them using methods from differerent packages in a single workflow."
keypoints:
- "Common methods and classes promote interoperability between packages, reduce redundant efforts by package developers, and facilitate the writing of workflows"
- "S4 classes can represent arbitrarily complex data structures."
- "S4 classes perform validity checks and report invalid object states."
---



> ## Contribute!
> 
> This episode is intended to introduce some core Bioconductor classes to illustrate key concepts of S4 classes and methods.
> Preferably some conceptually simple classes that can be used for intuitive exercises.
>
> The exercises should focus on illustrating:
>
> - slots
> - validity checks (and fails)
> - method dispatch
> - `show()` method (in contrast to the `str()` function)
> 
> For instance, use the *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* class to:
> 
> - Illustrate how to create a new object
> - Show that validity checks prevent the creation of invalid objects (e.g. only A-T-C-G in `DNAStringSet` objects).
>
{: .callout}

# Why standard classes?

> ## Contribute!
> 
> This section is a general discussion of the purpose and advantages of having standard classes re-used throughout the community.
> 
> Discuss:
> 
> - Interoperability.
> - Re-use and inheritance.
> - Community effort to discuss, develop, update, and maintain classes and methods.
>
{: .callout}


# S4 class system

## Overview

As users, we generally do not need to create our own S4 classes and methods.
However, to understand the key concepts of the S4 class system, this section walks us through the process of creating and interacting with a simple S4 class.

## Defining a new class

The [methods][pkg-methods] R package - included in the set of core packages installed with R - provides functions to define and register [S4 classes][glossary-s4-class].

A new S4 class is defined using the function `setClass`.
At its simplest, a class can defined from a name and a list of [slots][glossary-s4-slot].

The class name will be used to identify [S4 objects][glossary-s4-object] of that class, allowing [S4 method dispatch][glossary-method-dispatch] to call the appropriate method designed to process objects of that type.

Each [class slot][glossary-s4-slot] identified by its name and the type of data that it will contain.

- a name
- a named character vector of slots and data types that each slot is allowed to contain

For example, we can create a class called called "ClassA", that contains:

- a slot called "characterA", that can hold a `character` vector.
- a slot called "numericMatrixA", that can hold a `numeric` `matrix`.
- a slot called "dataframeA", that can hold a `data.frame`.


~~~
setClass("ClassA", slots=c(
    characterA = "character",
    numericMatrixA = "matrix",
    dataframeA = "data.frame"
    ))
~~~
{: .language-r}

> ## Slot names
> 
> The names of class slots are entirely arbitrary and defined by the author of the class.
> In this simple example, we give names that describe the type of data that they can hold.
> In practice, slot names tend to describe the conceptual nature of the data that they can contain (e.g., "raw_data", "assays", "metadata").
>
{: .callout}

## Instantiating objects of a class

Once a class has been defined, new objects of that class can be instantiated (i.e., created) using the `new()` function.
Those new objects can be assigned to variable name for subsequent use, including display in the console.


~~~
objectA1 <- new("ClassA")
objectA1
~~~
{: .language-r}



~~~
An object of class "ClassA"
Slot "characterA":
character(0)

Slot "numericMatrixA":
<0 x 0 matrix>

Slot "dataframeA":
data frame with 0 columns and 0 rows
~~~
{: .output}

Notice above that when we do not provide values for the various slots of the new object, each slot is automatically populated by an empty value of the correct type.
Instead, the `new()` function can be given named arguments that are used to populate the corresponding slot.


~~~
exampleCharacter <- c("A", "B", "C")
exampleNumericMatrix <- matrix(1)
exampleDataFrame <- data.frame(A = 1, B = 2)
objectA2 <- new("ClassA", 
    characterA = exampleCharacter,
    numericMatrixA = exampleNumericMatrix,
    dataframeA = exampleDataFrame
)
objectA2
~~~
{: .language-r}



~~~
An object of class "ClassA"
Slot "characterA":
[1] "A" "B" "C"

Slot "numericMatrixA":
     [,1]
[1,]    1

Slot "dataframeA":
  A B
1 1 2
~~~
{: .output}

Crucially, the definition of the slots ensures that we cannot assign data of the wrong type to any of the slots.
Each value that does not match the type of the slot generates a validity error message.


~~~
new("ClassA", 
    characterA = 2,
    numericMatrixA = matrix("A"),
    dataframeA = list(A = 1, B = 2)
)
~~~
{: .language-r}



~~~
Error in validObject(.Object): invalid class "ClassA" object: 1: invalid object for slot "characterA" in class "ClassA": got class "numeric", should be or extend class "character"
invalid class "ClassA" object: 2: invalid object for slot "dataframeA" in class "ClassA": got class "list", should be or extend class "data.frame"
~~~
{: .error}

However, rather than letting users call the `new()` function, it is generally best practice to implement a _contructor_ function.
A constructor function typically calls the `new()` function, after potentially performing additional validity checks beyond the built-in type-checking of values assigned to slots.
Often, _contructor_ function also process their own arguments into the actual values that will be stored in the various slots of the final object.
Best practice is to name constructor functions identically to the name of class that they instantiate objects for.


~~~
ClassA <- function(character, matrix, dataframe) {
    character <- as.character(character)
    matrix <- as.matrix(matrix)
    storage.mode(matrix) <- "numeric"
    dataframe <- as.data.frame(dataframe)
    new("ClassA", 
        characterA = character,
        numericMatrixA = matrix,
        dataframeA = dataframe
    )
}
~~~
{: .language-r}

We can then use the _constructor_ function to instantiate new objects.


~~~
objectA3 <- ClassA(
    character = exampleCharacter,
    matrix = exampleNumericMatrix,
    dataframe = exampleDataFrame)
objectA3
~~~
{: .language-r}



~~~
An object of class "ClassA"
Slot "characterA":
[1] "A" "B" "C"

Slot "numericMatrixA":
     [,1]
[1,]    1

Slot "dataframeA":
  A B
1 1 2
~~~
{: .output}


## Defining and using class methods

In contrast to regular functions, [S4 generics][TODO] and [S4 methods][TODO] use the class of their argument(s) to alter their behaviour and call the version of the method specifically implemented to handle that particular type of objects.

The generic defines the name of the method, as well as the arguments that will be used to dispatch calls to the appropriate method.
Instead, the method(s) define practical implementations of the generic for specific classes.

For instance, we define a new generic called "summarizeObject", which will dispatch calls according to the class of the argument `x`.


~~~
setGeneric(
    "summarizeObject",
    function(x) standardGeneric("summarizeObject")
)
~~~
{: .language-r}

However, the generic itself does not yet declare how to handle any particular class.
If we call it now, we see that the generic does not yet have a method capable of handling objects of the class "ClassA".


~~~
summarizeObject(objectA3)
~~~
{: .language-r}



~~~
Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'summarizeObject' for signature '"ClassA"'
~~~
{: .error}

We define a new method of the "summarizeObject" generic for the "summarizeObject" class, using the `setMethod()` function.
The function takes the name of the generic, the _signature_ of the method (i.e., the classes of the arguments for which it is defined), and the function that defines the behaviour of this method for this combination of arguments.
For example, we define this function to print some basic information about the object and its slots.


~~~
setMethod("summarizeObject", "ClassA", function(x) {
    cat(paste0("This is an object of class: ", class(x), "\n"))
    cat(paste0("It contains ", length(slotNames(x)), " slots named: ", paste0(slotNames(x), collapse = ", "), "\n"))
    cat(paste0("Slot characterA contains ", length(x@characterA), " character value(s).\n"))
    cat(paste0("Slot numericMatrixA contains ", nrow(x@numericMatrixA), " row(s) and ", ncol(x@numericMatrixA), " column(s).\n"))
    cat(paste0("Slot dataframeA contains ", nrow(x@dataframeA), " row(s) and ", ncol(x@dataframeA), " column(s)."))
})
summarizeObject(objectA3)
~~~
{: .language-r}



~~~
This is an object of class: ClassA
It contains 3 slots named: characterA, numericMatrixA, dataframeA
Slot characterA contains 3 character value(s).
Slot numericMatrixA contains 1 row(s) and 1 column(s).
Slot dataframeA contains 1 row(s) and 2 column(s).
~~~
{: .output}

> ## Contribute!
> 
> Illustrate `setValidity()`.
>
{: .callout}

> ## Challenge
> 
> Define another class called "ClassB".
> That class should contain two slots, one slot called "numericB" storing a numeric vector, and one slot called "logicalB" storing a logical vector.
> 
> Instantiate an object of class "ClassB".
> 
> Define a method of the generic "summarizeObject" for the "ClassB" class, that displays the number of values in slots "numericB" and "logicalB".
>
{: .challenge}


The [S4 method dispatch][glossary-s4-dispatch] system has several advantages:

- All methods for the same generic share the same name, reducing the cognitive load on users.
- Methods happily co-exist in the same workspace, with S4 method dispatch choosing the correct method based on the class of input arguments.
- Individual methods do not need to perform type-checking on arguments that are handled by the method dispatch, making methods easier to write and to read.


# Install packages

Before we can proceed into the following sections, we install some Bioconductor packages that we will need.


~~~
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("Biostrings")
~~~
{: .language-r}


# The Biostrings package and classes

Many bioinformatics analyses focus on biological sequences that are often represented as strings or characters vectors.
Examples include nucleic acid sequences (e.g., DNA, RNA), and protein sequences composed of aminoacids.

The *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package implements classes to represent such sequences as S4 classes, e.g. `DNAString`, `AAString`.
Those S4 classes provide memory-efficient string containers, while other methods implemented in the package provide various string matching algorithms and other utilities for fast manipulation of large biological sequences or sets of sequences.

A short presentation of the basic classes defined in the *[Biostrings](https://bioconductor.org/packages/3.13/Biostrings)* package is available in one of the package vignettes.


~~~
vignette("Biostrings2Classes")
~~~
{: .language-r}

To get started, we load the package.


~~~
library(Biostrings)
~~~
{: .language-r}

With the package loaded and attached to the session, we have access to the packages functions.
Those include functions that let us create new objects of the classes defined in the package; those functions are called _constructors_.
For instance, we can create an object that represents a DNA sequence, using the `DNAString()` constructor function.


~~~
DNAString("ATCG")
~~~
{: .language-r}



~~~
4-letter DNAString object
seq: ATCG
~~~
{: .output}

Notably, DNA sequences may only contain the characters A, T, C, and G, to represent the four DNA nucleotide.
Notice that the constructor function does not let us create objects that contain invalid characters, that do not represent any of those four nucleotide.


~~~
DNAString("ATCG")
~~~
{: .language-r}



~~~
4-letter DNAString object
seq: ATCG
~~~
{: .output}


~~~
DNAString("ATCGE")
~~~
{: .language-r}



~~~
Error in .Call2("new_XString_from_CHARACTER", class(x0), string, start, : key 69 (char 'E') not in lookup table
~~~
{: .error}

That said, the symbols that compose the alphabet DNA sequences are not limited to the characters A, T, C, and G.
The [IUPAC Extended Genetic Alphabet][iupac-alphabet] defines additional nucleotide code that represent combinations of nucleotides, in a way similar to regular expressions.
The `IUPAC_CODE_MAP` 


~~~
IUPAC_CODE_MAP
~~~
{: .language-r}



~~~
     A      C      G      T      M      R      W      S      Y      K      V 
   "A"    "C"    "G"    "T"   "AC"   "AG"   "AT"   "CG"   "CT"   "GT"  "ACG" 
     H      D      B      N 
 "ACT"  "AGT"  "CGT" "ACGT" 
~~~
{: .output}

Any of those nucleotide codes are allowed in the sequence of a `DNAString` object.


~~~
DNAString("ATCGM")
~~~
{: .language-r}



~~~
5-letter DNAString object
seq: ATCGM
~~~
{: .output}

[pkg-methods]: https://stat.ethz.ch/R-manual/R-devel/library/methods/html/00Index.html
[iupac-alphabet]: https://www.bioinformatics.org/sms/iupac.html
[glossary-s4-slot]: ../reference.html#s4-class-slot
[glossary-s4-class]: ../reference.html#s4-class
[glossary-s4-object]: ../reference.html#s4-object
[glossary-s4-dispatch]: ../reference.html#s4-method-dispatch
